package main

import (
	myInOut "NewPipeLine/cmd"
	fl "NewPipeLine/feature_logging"
	fu "NewPipeLine/functions"
	"NewPipeLine/steps"
	"sync"
)


	// Напишите код, реализующий пайплайн, работающий с целыми числами и состоящий из следующих стадий:

	// Стадия фильтрации отрицательных чисел (не пропускать отрицательные числа).
	//Стадия фильтрации чисел, не кратных 3 (не пропускать такие числа), исключая также и 0.
	//Стадия буферизации данных в кольцевом буфере с интерфейсом, соответствующим тому,
	//который был дан в качестве задания в 19 модуле. В этой стадии предусмотреть опустошение
	//буфера (и соответственно, передачу этих данных, если они есть, дальше) с определённым
	//интервалом во времени. Значения размера буфера и этого интервала времени сделать
	//настраиваемыми (как мы делали: через константы или глобальные переменные).

	// Написать источник данных для конвейера. Непосредственным источником данных должна быть консоль.
	//
	//Также написать код потребителя данных конвейера. Данные от конвейера
	//можно направить снова в консоль построчно, сопроводив их каким-нибудь поясняющим текстом,
	//например: «Получены данные …».
	//
	//При написании источника данных подумайте о фильтрации нечисловых данных,
	//которые можно ввести через консоль. Как и где их фильтровать, решайте сами.

var sizeOfBuff int // размер выходного буфера
var releaseBuffPer int // период опустошения выходного буфера


func main(){

	// Функции стартующие и завершающие логирование
	fl.LoggerStart()
	defer fl.LoggerStop()

	// Для удобства введены ограничения: минимальный размер буфера 1, минимальное время опустошения буфера 1
	// минимальное количество потоков 1.


	myInput := myInOut.NewInput() 	// Создали читающую и пишущую в канал структуру
									// считали ей всё что нужно:

	 sizeOfBuff = myInput.Read("Введите размер выходного буфера", "Значение не распознано")
	 releaseBuffPer = myInput.Read("Введите период опустошения  выходного буфера", "Значение не распознано")
	 amOfGo := myInput.Read("Введите количество потоков обработки ", "Значение не распознано")


	wg := sync.WaitGroup{} // Wait группа ждёт ввода завершающего значения
	wg.Add(1)

	myInputChan := myInput.Start(&wg) 	// Стартуем источник ввода


	// формируем ступени обработки добавляя функцию с соответствующей сигнатурой в список
	fu.ToDo = append(fu.ToDo, fu.NoMinus)   // Стадия фильтрации отрицательных чисел (не пропускать отрицательные числа).
	fu.ToDo = append(fu.ToDo, fu.By3AndNo0)	//Стадия фильтрации чисел, не кратных 3 (не пропускать такие числа), исключая также и 0.

	myPipeLine := steps.NewPipeLine(myInputChan, fu.ToDo )
	toOutputChan := myPipeLine.Start(amOfGo)



	myOut := myInOut.NewOutPut(sizeOfBuff, releaseBuffPer)

	myOut.Start(toOutputChan, myInput.GetInputBuff())

	wg.Wait()

}
